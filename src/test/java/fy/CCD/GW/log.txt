commit msg: Merge "Part 3: Migrate ChangeIndex FieldDefs to the new format SchemaFields"
v1: 619c1a1384607450b03e9d8a9a7d3e0ea3982123    v2: 72f4574492eb752a0c9f2e59bb31b6eb6667bc81
file name: ChangePredicates.java
change region: 
(line 231,col 0)-(line 232,col 0)
original method: 
public static Predicate<ChangeData> file(ChangeQueryBuilder.Arguments args, String file) {
    Predicate<ChangeData> eqPath = path(file);
    if (!args.getSchema().hasField(ChangeField.FILE_PART)) {
        return eqPath;
    }
    return Predicate.or(eqPath, new ChangeIndexPredicate(ChangeField.FILE_PART, file));
}
(line 230,col 3)-(line 236,col 3)
original graph vertexes: 5
sliced method: 
public static Predicate<ChangeData> file(ChangeQueryBuilder.Arguments args, String file) {
    if (!args.getSchema().hasField(ChangeField.FILE_PART)) {
    }
}
(line 230,col 3)-(line 236,col 3)slice vertexes: 3




commit msg: Merge "Part 3: Migrate ChangeIndex FieldDefs to the new format SchemaFields"
v1: 619c1a1384607450b03e9d8a9a7d3e0ea3982123    v2: 72f4574492eb752a0c9f2e59bb31b6eb6667bc81
file name: ChangePredicates.java
change region: 
(line 234,col 0)-(line 235,col 0)
original method: 
public static Predicate<ChangeData> file(ChangeQueryBuilder.Arguments args, String file) {
    Predicate<ChangeData> eqPath = path(file);
    if (!args.getSchema().hasField(ChangeField.FILE_PART)) {
        return eqPath;
    }
    return Predicate.or(eqPath, new ChangeIndexPredicate(ChangeField.FILE_PART, file));
}
(line 230,col 3)-(line 236,col 3)
original graph vertexes: 5
sliced method: 
public static Predicate<ChangeData> file(ChangeQueryBuilder.Arguments args, String file) {
    Predicate<ChangeData> eqPath = path(file);
    return Predicate.or(eqPath, new ChangeIndexPredicate(ChangeField.FILE_PART, file));
}
(line 230,col 3)-(line 236,col 3)slice vertexes: 3




commit msg: Merge "Part 3: Migrate ChangeIndex FieldDefs to the new format SchemaFields"
v1: 619c1a1384607450b03e9d8a9a7d3e0ea3982123    v2: 72f4574492eb752a0c9f2e59bb31b6eb6667bc81
file name: ChangePredicates.java
change region: 
(line 249,col 0)-(line 250,col 0)
original method: 
public static Predicate<ChangeData> footer(String footer) {
    int indexEquals = footer.indexOf('=');
    int indexColon = footer.indexOf(':');
    if (indexEquals > 0 && (indexEquals < indexColon || indexColon < 0)) {
        footer = footer.substring(0, indexEquals) + ": " + footer.substring(indexEquals + 1);
    }
    return new ChangeIndexPredicate(ChangeField.FOOTER, footer.toLowerCase(Locale.US));
}
(line 242,col 3)-(line 251,col 3)
original graph vertexes: 6
sliced method: 
public static Predicate<ChangeData> footer(String footer) {
    int indexEquals = footer.indexOf('=');
    if (indexEquals > 0 && (indexEquals < indexColon || indexColon < 0)) {
        footer = footer.substring(0, indexEquals) + ": " + footer.substring(indexEquals + 1);
    }
    return new ChangeIndexPredicate(ChangeField.FOOTER, footer.toLowerCase(Locale.US));
}
(line 242,col 3)-(line 251,col 3)slice vertexes: 5




commit msg: Merge "Part 3: Migrate ChangeIndex FieldDefs to the new format SchemaFields"
v1: 619c1a1384607450b03e9d8a9a7d3e0ea3982123    v2: 72f4574492eb752a0c9f2e59bb31b6eb6667bc81
file name: ChangePredicates.java
change region: 
(line 265,col 0)-(line 266,col 0)
original method: 
public static Predicate<ChangeData> directory(String directory) {
    return new ChangeIndexPredicate(ChangeField.DIRECTORY, CharMatcher.is('/').trimFrom(directory).toLowerCase(Locale.US));
}
(line 264,col 3)-(line 267,col 3)
original graph vertexes: 2
sliced method: 
public static Predicate<ChangeData> directory(String directory) {
}
(line 264,col 3)-(line 267,col 3)slice vertexes: 1




commit msg: Merge "Part 3: Migrate ChangeIndex FieldDefs to the new format SchemaFields"
v1: 619c1a1384607450b03e9d8a9a7d3e0ea3982123    v2: 72f4574492eb752a0c9f2e59bb31b6eb6667bc81
file name: ChangePredicates.java
change region: 
(line 289,col 0)-(line 290,col 0)
original method: 
public static Predicate<ChangeData> exactCommitter(String exactCommitter) {
    return new ChangeIndexPredicate(ChangeField.EXACT_COMMITTER, exactCommitter.toLowerCase(Locale.US));
}
(line 288,col 3)-(line 291,col 3)
original graph vertexes: 2
sliced method: 
public static Predicate<ChangeData> exactCommitter(String exactCommitter) {
}
(line 288,col 3)-(line 291,col 3)slice vertexes: 1




commit msg: Merge "Part 3: Migrate ChangeIndex FieldDefs to the new format SchemaFields"
v1: 619c1a1384607450b03e9d8a9a7d3e0ea3982123    v2: 72f4574492eb752a0c9f2e59bb31b6eb6667bc81
file name: ChangeQueryBuilder.java
change region: 
(line 671,col 0)-(line 672,col 0)
original method: 
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredBySelf();
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return isVisible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return ChangePredicates.unreviewed();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return ChangePredicates.owner(self());
    }
    if ("uploader".equalsIgnoreCase(value)) {
        checkFieldAvailable(ChangeField.UPLOADER, "is:uploader");
        return ChangePredicates.uploader(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP)), ReviewerPredicate.reviewer(self()));
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        if (!args.indexMergeable) {
            throw new QueryParseException("'is:mergeable' operator is not supported by server");
        }
        return new BooleanPredicate(ChangeField.MERGEABLE);
    }
    if ("merge".equalsIgnoreCase(value)) {
        checkFieldAvailable(ChangeField.MERGE, "is:merge");
        return new BooleanPredicate(ChangeField.MERGE);
    }
    if ("private".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.PRIVATE);
    }
    if ("attention".equalsIgnoreCase(value)) {
        checkFieldAvailable(ChangeField.ATTENTION_SET_USERS, "is:attention");
        return new IsAttentionPredicate();
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(ChangePredicates.assignee(Account.id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return ChangePredicates.assignee(Account.id(ChangeField.NO_ASSIGNEE));
    }
    if ("pure-revert".equalsIgnoreCase(value)) {
        checkFieldAvailable(ChangeField.IS_PURE_REVERT, "is:pure-revert");
        return ChangePredicates.pureRevert("1");
    }
    if ("submittable".equalsIgnoreCase(value)) {
        if (!args.index.getSchema().hasField(ChangeField.IS_SUBMITTABLE)) {
            return Predicate.and(new SubmittablePredicate(SubmitRecord.Status.OK), Predicate.not(new SubmittablePredicate(SubmitRecord.Status.NOT_READY)), Predicate.not(new SubmittablePredicate(SubmitRecord.Status.RULE_ERROR)));
        }
        checkFieldAvailable(ChangeField.IS_SUBMITTABLE, "is:submittable");
        return new IsSubmittablePredicate();
    }
    if ("started".equalsIgnoreCase(value)) {
        checkFieldAvailable(ChangeField.STARTED, "is:started");
        return new BooleanPredicate(ChangeField.STARTED);
    }
    if ("wip".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.WIP);
    }
    if ("cherrypick".equalsIgnoreCase(value)) {
        checkFieldAvailable(ChangeField.CHERRY_PICK, "is:cherrypick");
        return new BooleanPredicate(ChangeField.CHERRY_PICK);
    }
    List<String> names = PLUGIN_SPLITTER.splitToList(value);
    if (names.size() == 2) {
        ChangeIsOperandFactory op = args.isOperands.get(names.get(1), names.get(0));
        if (op != null) {
            return op.create(this);
        }
    }
    return status(value);
}
(line 649,col 3)-(line 758,col 3)
original graph vertexes: 56
sliced method: 
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("uploader".equalsIgnoreCase(value)) {
        checkFieldAvailable(ChangeField.UPLOADER, "is:uploader");
    }
}
(line 649,col 3)-(line 758,col 3)slice vertexes: 4




commit msg: Merge "Part 3: Migrate ChangeIndex FieldDefs to the new format SchemaFields"
v1: 619c1a1384607450b03e9d8a9a7d3e0ea3982123    v2: 72f4574492eb752a0c9f2e59bb31b6eb6667bc81
file name: ChangeQueryBuilder.java
change region: 
(line 1205,col 0)-(line 1206,col 0)
original method: 
@Operator
public Predicate<ChangeData> uploader(String who) throws QueryParseException, IOException, ConfigInvalidException {
    checkFieldAvailable(ChangeField.UPLOADER, "uploader");
    return uploader(parseAccount(who, (AccountState s) -> true));
}
(line 1203,col 3)-(line 1208,col 3)
original graph vertexes: 3
sliced method: 
@Operator
public Predicate<ChangeData> uploader(String who) throws QueryParseException, IOException, ConfigInvalidException {
    checkFieldAvailable(ChangeField.UPLOADER, "uploader");
}
(line 1203,col 3)-(line 1208,col 3)slice vertexes: 2




commit msg: Merge "Part 3: Migrate ChangeIndex FieldDefs to the new format SchemaFields"
v1: 619c1a1384607450b03e9d8a9a7d3e0ea3982123    v2: 72f4574492eb752a0c9f2e59bb31b6eb6667bc81
file name: ChangeQueryBuilder.java
change region: 
(line 1265,col 0)-(line 1266,col 0)
original method: 
@Operator
public Predicate<ChangeData> uploaderin(String group) throws QueryParseException, IOException {
    checkFieldAvailable(ChangeField.UPLOADER, "uploaderin");
    GroupReference g = GroupBackends.findBestSuggestion(args.groupBackend, group);
    if (g == null) {
        throw error("Group " + group + " not found");
    }
    AccountGroup.UUID groupId = g.getUUID();
    GroupDescription.Basic groupDescription = args.groupBackend.get(groupId);
    if (!(groupDescription instanceof GroupDescription.Internal)) {
        return new UploaderinPredicate(args.userFactory, groupId);
    }
    Set<Account.Id> accounts = getMembers(groupId);
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(accounts.size());
    for (Account.Id id : accounts) {
        p.add(ChangePredicates.uploader(id));
    }
    return Predicate.or(p);
}
(line 1264,col 3)-(line 1285,col 3)
original graph vertexes: 14
sliced method: 
@Operator
public Predicate<ChangeData> uploaderin(String group) throws QueryParseException, IOException {
    checkFieldAvailable(ChangeField.UPLOADER, "uploaderin");
}
(line 1264,col 3)-(line 1285,col 3)slice vertexes: 2




commit msg: Merge "Part 3: Migrate ChangeIndex FieldDefs to the new format SchemaFields"
v1: 619c1a1384607450b03e9d8a9a7d3e0ea3982123    v2: 72f4574492eb752a0c9f2e59bb31b6eb6667bc81
file name: IndexUpgradeValidatorTest.java
change region: 
(line 38,col 0)-(line 39,col 0)
original method: 
@Test
public void valid() {
    IndexUpgradeValidator.assertValid(schema(1, ChangeField.ID), schema(2, ChangeField.ID));
    IndexUpgradeValidator.assertValid(schema(1, ChangeField.ID), schema(2, ChangeField.ID, ChangeField.OWNER));
    IndexUpgradeValidator.assertValid(schema(1, ChangeField.ID), schema(2, ChangeField.ID, ChangeField.OWNER, ChangeField.COMMITTER));
}
(line 35,col 3)-(line 43,col 3)
original graph vertexes: 4
sliced method: 
@Test
public void valid() {
}
(line 35,col 3)-(line 43,col 3)slice vertexes: 1




commit msg: Merge "Part 3: Migrate ChangeIndex FieldDefs to the new format SchemaFields"
v1: 619c1a1384607450b03e9d8a9a7d3e0ea3982123    v2: 72f4574492eb752a0c9f2e59bb31b6eb6667bc81
file name: IndexUpgradeValidatorTest.java
change region: 
(line 41,col 0)-(line 42,col 0)
original method: 
@Test
public void valid() {
    IndexUpgradeValidator.assertValid(schema(1, ChangeField.ID), schema(2, ChangeField.ID));
    IndexUpgradeValidator.assertValid(schema(1, ChangeField.ID), schema(2, ChangeField.ID, ChangeField.OWNER));
    IndexUpgradeValidator.assertValid(schema(1, ChangeField.ID), schema(2, ChangeField.ID, ChangeField.OWNER, ChangeField.COMMITTER));
}
(line 35,col 3)-(line 43,col 3)
original graph vertexes: 4
sliced method: 
@Test
public void valid() {
}
(line 35,col 3)-(line 43,col 3)slice vertexes: 1




commit msg: Merge "Part 3: Migrate ChangeIndex FieldDefs to the new format SchemaFields"
v1: 619c1a1384607450b03e9d8a9a7d3e0ea3982123    v2: 72f4574492eb752a0c9f2e59bb31b6eb6667bc81
file name: IndexUpgradeValidatorTest.java
change region: 
(line 51,col 0)-(line 52,col 0)
original method: 
@Test
public void invalid_addAndRemove() {
    AssertionError e = assertThrows(AssertionError.class, () -> IndexUpgradeValidator.assertValid(schema(1, ChangeField.ID), schema(2, ChangeField.OWNER)));
    assertThat(e).hasMessageThat().contains("Schema upgrade to version 2 may either add or remove fields, but not both");
}
(line 45,col 3)-(line 56,col 3)
original graph vertexes: 3
sliced method: 
@Test
public void invalid_addAndRemove() {
}
(line 45,col 3)-(line 56,col 3)slice vertexes: 1




commit msg: Merge "Part 3: Migrate ChangeIndex FieldDefs to the new format SchemaFields"
v1: 619c1a1384607450b03e9d8a9a7d3e0ea3982123    v2: 72f4574492eb752a0c9f2e59bb31b6eb6667bc81
file name: AbstractQueryChangesTest.java
change region: 
(line 628,col 0)-(line 629,col 0)
original method: 
@Test
public void byUploader() throws Exception {
    assume().that(getSchema().hasField(ChangeField.UPLOADER)).isTrue();
    Account.Id user2 = accountManager.authenticate(authRequestFactory.createForUser("anotheruser")).getAccountId();
    CurrentUser user2CurrentUser = userFactory.create(user2);
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    assertQuery("is:uploader", change1);
    assertQuery("uploader:" + userId.get(), change1);
    change1 = newPatchSet(repo, change1, user2CurrentUser);
    assertQuery("uploader:" + userId.get());
    assertQuery("uploader:" + user2.get(), change1);
    requestContext.setContext(newRequestContext(user2));
    assertQuery("is:uploader", change1);
    String nameEmail = user2CurrentUser.asIdentifiedUser().getNameEmail();
    assertQuery("uploader: \"" + nameEmail + "\"", change1);
}
(line 627,col 3)-(line 648,col 3)
original graph vertexes: 15
sliced method: 
@Test
public void byUploader() throws Exception {
    assume().that(getSchema().hasField(ChangeField.UPLOADER)).isTrue();
}
(line 627,col 3)-(line 648,col 3)slice vertexes: 2




commit msg: Merge "Part 3: Migrate ChangeIndex FieldDefs to the new format SchemaFields"
v1: 619c1a1384607450b03e9d8a9a7d3e0ea3982123    v2: 72f4574492eb752a0c9f2e59bb31b6eb6667bc81
file name: AbstractQueryChangesTest.java
change region: 
(line 764,col 0)-(line 765,col 0)
original method: 
@Test
public void byUploaderIn() throws Exception {
    assume().that(getSchema().hasField(ChangeField.UPLOADER)).isTrue();
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    assertQuery("uploaderin:Administrators", change1);
    Account.Id user2 = accountManager.authenticate(authRequestFactory.createForUser("anotheruser")).getAccountId();
    CurrentUser user2CurrentUser = userFactory.create(user2);
    newPatchSet(repo, change1, user2CurrentUser);
    assertQuery("uploaderin:Administrators");
}
(line 763,col 3)-(line 775,col 3)
original graph vertexes: 9
sliced method: 
@Test
public void byUploaderIn() throws Exception {
    assume().that(getSchema().hasField(ChangeField.UPLOADER)).isTrue();
}
(line 763,col 3)-(line 775,col 3)slice vertexes: 2




commit msg: Merge "Replace "line" with "range.endLine" in CommentInput"
v1: 90de9857c485273e7ebdf2f7bf754d53e7a7badb    v2: 619c1a1384607450b03e9d8a9a7d3e0ea3982123
file name: Comment.java
change region: 
(line 266,col 0)-(line 267,col 0)
original method: 
public void setLineNbrAndRange(Integer lineNbr, com.google.gerrit.extensions.client.Comment.Range range) {
    this.lineNbr = lineNbr != null ? lineNbr : range != null ? range.endLine : 0;
    if (range != null) {
        this.range = new Comment.Range(range);
    }
}
(line 265,col 3)-(line 271,col 3)
original graph vertexes: 5
sliced method: 
public void setLineNbrAndRange(Integer lineNbr, com.google.gerrit.extensions.client.Comment.Range range) {
    this.lineNbr = lineNbr != null ? lineNbr : range != null ? range.endLine : 0;
}
(line 265,col 3)-(line 271,col 3)slice vertexes: 2




commit msg: Replace "line" with "range.endLine" in CommentInput
v1: 67cc082e9741940c8d1075d4b6258822114beb41    v2: 884eb689b3e967c56132ecb05b505b9c5d1a8206
file name: Comment.java
change region: 
(line 266,col 0)-(line 267,col 0)
original method: 
public void setLineNbrAndRange(Integer lineNbr, com.google.gerrit.extensions.client.Comment.Range range) {
    this.lineNbr = lineNbr != null ? lineNbr : range != null ? range.endLine : 0;
    if (range != null) {
        this.range = new Comment.Range(range);
    }
}
(line 265,col 3)-(line 271,col 3)
original graph vertexes: 5
sliced method: 
public void setLineNbrAndRange(Integer lineNbr, com.google.gerrit.extensions.client.Comment.Range range) {
    this.lineNbr = lineNbr != null ? lineNbr : range != null ? range.endLine : 0;
}
(line 265,col 3)-(line 271,col 3)slice vertexes: 2




commit msg: Split approval parsing logic into separate NoteDb util
v1: 12ab14dca318beb58c0473c7b29d6978de09bba0    v2: e1d181208d6198682e1ac2d4c702515968323c04
file name: ChangeNoteUtil.java


commit msg: Split approval parsing logic into separate NoteDb util
v1: 12ab14dca318beb58c0473c7b29d6978de09bba0    v2: e1d181208d6198682e1ac2d4c702515968323c04
file name: ChangeNotesParser.java
change region: 
(line 944,col 0)-(line 945,col 0)
original method: 
private void parseCopiedApproval(PatchSet.Id psId, Instant ts, String line) throws ConfigInvalidException {
    ParsedPatchSetApproval parsedPatchSetApproval = ChangeNoteUtil.parseCopiedApproval(line);
    checkFooter(parsedPatchSetApproval.accountIdent().isPresent(), FOOTER_COPIED_LABEL, parsedPatchSetApproval.footerLine());
    PersonIdent accountIdent = RawParseUtils.parsePersonIdent(parsedPatchSetApproval.accountIdent().get());
    checkFooter(accountIdent != null, FOOTER_COPIED_LABEL, parsedPatchSetApproval.footerLine());
    Account.Id accountId = parseIdent(accountIdent);
    Account.Id realAccountId = null;
    if (parsedPatchSetApproval.realAccountIdent().isPresent()) {
        PersonIdent realIdent = RawParseUtils.parsePersonIdent(parsedPatchSetApproval.realAccountIdent().get());
        checkFooter(realIdent != null, FOOTER_COPIED_LABEL, parsedPatchSetApproval.footerLine());
        realAccountId = parseIdent(realIdent);
    }
    LabelVote labelVote;
    try {
        if (!parsedPatchSetApproval.isRemoval()) {
            labelVote = LabelVote.parseWithEquals(parsedPatchSetApproval.labelVote());
        } else {
            String labelName = parsedPatchSetApproval.labelVote();
            LabelType.checkNameInternal(labelName);
            labelVote = LabelVote.create(labelName, (short) 0);
        }
    } catch (IllegalArgumentException e) {
        ConfigInvalidException pe = parseException("invalid %s: %s", FOOTER_COPIED_LABEL, parsedPatchSetApproval.footerLine());
        pe.initCause(e);
        throw pe;
    }
    PatchSetApproval.Builder psa = PatchSetApproval.builder().key(PatchSetApproval.key(psId, accountId, LabelId.create(labelVote.label()))).uuid(parsedPatchSetApproval.uuid().map(PatchSetApproval::uuid)).value(labelVote.value()).granted(ts).tag(parsedPatchSetApproval.tag()).copied(true);
    if (realAccountId != null) {
        psa.realAccountId(realAccountId);
    }
    approvals.putIfAbsent(psa.key(), psa);
    bufferedApprovals.add(psa);
}
(line 943,col 3)-(line 994,col 3)
original graph vertexes: 24
sliced method: 
private void parseCopiedApproval(PatchSet.Id psId, Instant ts, String line) throws ConfigInvalidException {
    ParsedPatchSetApproval parsedPatchSetApproval = ChangeNoteUtil.parseCopiedApproval(line);
    checkFooter(parsedPatchSetApproval.accountIdent().isPresent(), FOOTER_COPIED_LABEL, parsedPatchSetApproval.footerLine());
    PersonIdent accountIdent = RawParseUtils.parsePersonIdent(parsedPatchSetApproval.accountIdent().get());
    checkFooter(accountIdent != null, FOOTER_COPIED_LABEL, parsedPatchSetApproval.footerLine());
    if (parsedPatchSetApproval.realAccountIdent().isPresent()) {
        PersonIdent realIdent = RawParseUtils.parsePersonIdent(parsedPatchSetApproval.realAccountIdent().get());
        checkFooter(realIdent != null, FOOTER_COPIED_LABEL, parsedPatchSetApproval.footerLine());
    }
    try {
        if (!parsedPatchSetApproval.isRemoval()) {
            labelVote = LabelVote.parseWithEquals(parsedPatchSetApproval.labelVote());
        } else {
            String labelName = parsedPatchSetApproval.labelVote();
        }
    } catch (IllegalArgumentException e) {
    }
    PatchSetApproval.Builder psa = PatchSetApproval.builder().key(PatchSetApproval.key(psId, accountId, LabelId.create(labelVote.label()))).uuid(parsedPatchSetApproval.uuid().map(PatchSetApproval::uuid)).value(labelVote.value()).granted(ts).tag(parsedPatchSetApproval.tag()).copied(true);
}
(line 943,col 3)-(line 994,col 3)slice vertexes: 14




commit msg: Split approval parsing logic into separate NoteDb util
v1: 12ab14dca318beb58c0473c7b29d6978de09bba0    v2: e1d181208d6198682e1ac2d4c702515968323c04
file name: ChangeNotesParser.java
change region: 
(line 1002,col 0)-(line 1003,col 0)
original method: 
private void parseApproval(PatchSet.Id psId, Account.Id accountId, Account.Id realAccountId, Instant ts, String line) throws ConfigInvalidException {
    if (accountId == null) {
        throw parseException("patch set %s requires an identified user as uploader", psId.get());
    }
    PatchSetApproval.Builder psa;
    ParsedPatchSetApproval parsedPatchSetApproval = ChangeNoteUtil.parseApproval(line);
    if (line.startsWith("-")) {
        psa = parseRemoveApproval(psId, accountId, realAccountId, ts, parsedPatchSetApproval);
    } else {
        psa = parseAddApproval(psId, accountId, realAccountId, ts, parsedPatchSetApproval);
    }
    bufferedApprovals.add(psa);
}
(line 996,col 3)-(line 1010,col 3)
original graph vertexes: 10
sliced method: 
private void parseApproval(PatchSet.Id psId, Account.Id accountId, Account.Id realAccountId, Instant ts, String line) throws ConfigInvalidException {
    ParsedPatchSetApproval parsedPatchSetApproval = ChangeNoteUtil.parseApproval(line);
    if (line.startsWith("-")) {
        psa = parseRemoveApproval(psId, accountId, realAccountId, ts, parsedPatchSetApproval);
    } else {
        psa = parseAddApproval(psId, accountId, realAccountId, ts, parsedPatchSetApproval);
    }
    bufferedApprovals.add(psa);
}
(line 996,col 3)-(line 1010,col 3)slice vertexes: 7




commit msg: Add more logging around GitVisibleChangeFilter and remove possible duplicates
v1: 74f27feea28c3ae8a3e9c1027b31e4006fe3a5ec    v2: 12ab14dca318beb58c0473c7b29d6978de09bba0
file name: SearchingChangeCacheImpl.java
change region: 
(line 166,col 0)-(line 167,col 0)
original method: 
@Override
public List<CachedChange> load(Project.NameKey key) throws Exception {
    try (TraceTimer timer = TraceContext.newTimer("Loading changes of project", Metadata.builder().projectName(key.get()).build());
        ManualRequestContext ctx = requestContext.open()) {
        List<ChangeData> cds = queryProvider.get().setRequestedFields(ChangeField.CHANGE, ChangeField.REVIEWER).byProject(key);
        List<CachedChange> result = new ArrayList<>(cds.size());
        for (ChangeData cd : cds) {
            result.add(new AutoValue_SearchingChangeCacheImpl_CachedChange(cd.change(), cd.reviewers()));
        }
        return Collections.unmodifiableList(result);
    }
}
(line 156,col 5)-(line 174,col 5)
original graph vertexes: 7
sliced method: 
@Override
public List<CachedChange> load(Project.NameKey key) throws Exception {
    try (TraceTimer timer = TraceContext.newTimer("Loading changes of project", Metadata.builder().projectName(key.get()).build());
        ManualRequestContext ctx = requestContext.open()) {
        List<ChangeData> cds = queryProvider.get().setRequestedFields(ChangeField.CHANGE, ChangeField.REVIEWER).byProject(key);
        List<CachedChange> result = new ArrayList<>(cds.size());
        for (ChangeData cd : cds) {
            result.add(new AutoValue_SearchingChangeCacheImpl_CachedChange(cd.change(), cd.reviewers()));
        }
        return Collections.unmodifiableList(result);
    }
}
(line 156,col 5)-(line 174,col 5)slice vertexes: 7




commit msg: Add more logging around GitVisibleChangeFilter and remove possible duplicates
v1: 74f27feea28c3ae8a3e9c1027b31e4006fe3a5ec    v2: 12ab14dca318beb58c0473c7b29d6978de09bba0
file name: SearchingChangeCacheImpl.java
change region: 
(line 168,col 0)-(line 169,col 0)
original method: 
@Override
public List<CachedChange> load(Project.NameKey key) throws Exception {
    try (TraceTimer timer = TraceContext.newTimer("Loading changes of project", Metadata.builder().projectName(key.get()).build());
        ManualRequestContext ctx = requestContext.open()) {
        List<ChangeData> cds = queryProvider.get().setRequestedFields(ChangeField.CHANGE, ChangeField.REVIEWER).byProject(key);
        List<CachedChange> result = new ArrayList<>(cds.size());
        for (ChangeData cd : cds) {
            result.add(new AutoValue_SearchingChangeCacheImpl_CachedChange(cd.change(), cd.reviewers()));
        }
        return Collections.unmodifiableList(result);
    }
}
(line 156,col 5)-(line 174,col 5)
original graph vertexes: 7
sliced method: 
@Override
public List<CachedChange> load(Project.NameKey key) throws Exception {
    try (TraceTimer timer = TraceContext.newTimer("Loading changes of project", Metadata.builder().projectName(key.get()).build());
        ManualRequestContext ctx = requestContext.open()) {
        List<ChangeData> cds = queryProvider.get().setRequestedFields(ChangeField.CHANGE, ChangeField.REVIEWER).byProject(key);
        List<CachedChange> result = new ArrayList<>(cds.size());
        for (ChangeData cd : cds) {
            result.add(new AutoValue_SearchingChangeCacheImpl_CachedChange(cd.change(), cd.reviewers()));
        }
    }
}
(line 156,col 5)-(line 174,col 5)slice vertexes: 6




commit msg: Add more logging around GitVisibleChangeFilter and remove possible duplicates
v1: 74f27feea28c3ae8a3e9c1027b31e4006fe3a5ec    v2: 12ab14dca318beb58c0473c7b29d6978de09bba0
file name: SearchingChangeCacheImpl.java
change region: 
(line 171,col 0)-(line 172,col 0)
original method: 
@Override
public List<CachedChange> load(Project.NameKey key) throws Exception {
    try (TraceTimer timer = TraceContext.newTimer("Loading changes of project", Metadata.builder().projectName(key.get()).build());
        ManualRequestContext ctx = requestContext.open()) {
        List<ChangeData> cds = queryProvider.get().setRequestedFields(ChangeField.CHANGE, ChangeField.REVIEWER).byProject(key);
        List<CachedChange> result = new ArrayList<>(cds.size());
        for (ChangeData cd : cds) {
            result.add(new AutoValue_SearchingChangeCacheImpl_CachedChange(cd.change(), cd.reviewers()));
        }
        return Collections.unmodifiableList(result);
    }
}
(line 156,col 5)-(line 174,col 5)
original graph vertexes: 7
sliced method: 
@Override
public List<CachedChange> load(Project.NameKey key) throws Exception {
    try (TraceTimer timer = TraceContext.newTimer("Loading changes of project", Metadata.builder().projectName(key.get()).build());
        ManualRequestContext ctx = requestContext.open()) {
        List<ChangeData> cds = queryProvider.get().setRequestedFields(ChangeField.CHANGE, ChangeField.REVIEWER).byProject(key);
        List<CachedChange> result = new ArrayList<>(cds.size());
        return Collections.unmodifiableList(result);
    }
}
(line 156,col 5)-(line 174,col 5)slice vertexes: 5




commit msg: Add more logging around GitVisibleChangeFilter and remove possible duplicates
v1: 74f27feea28c3ae8a3e9c1027b31e4006fe3a5ec    v2: 12ab14dca318beb58c0473c7b29d6978de09bba0
file name: GitVisibleChangeFilter.java
change region: 
(line 74,col 0)-(line 74,col 0)
original method: 
static ImmutableMap<Change.Id, ChangeData> getVisibleChanges(@Nullable SearchingChangeCacheImpl searchingChangeCache, ChangeNotes.Factory changeNotesFactory, ChangeData.Factory changeDataFactory, Project.NameKey projectName, PermissionBackend.ForProject forProject, Repository repository, ImmutableSet<Change.Id> changes) {
    Stream<ChangeData> changeDatas;
    if (changes.size() < CHANGE_LIMIT_FOR_DIRECT_FILTERING) {
        changeDatas = loadChangeDatasOneByOne(changes, changeDataFactory, projectName);
    } else if (searchingChangeCache != null) {
        changeDatas = searchingChangeCache.getChangeData(projectName);
    } else {
        changeDatas = scanRepoForChangeDatas(changeNotesFactory, changeDataFactory, repository, projectName);
    }
    return changeDatas.filter(cd -> changes.contains(cd.getId())).filter(cd -> {
        try {
            return forProject.change(cd).test(ChangePermission.READ);
        } catch (PermissionBackendException e) {
            throw new StorageException(e);
        }
    }).collect(toImmutableMap(ChangeData::getId, Function.identity()));
}
(line 65,col 3)-(line 94,col 3)
original graph vertexes: 9
sliced method: 
static ImmutableMap<Change.Id, ChangeData> getVisibleChanges(@Nullable SearchingChangeCacheImpl searchingChangeCache, ChangeNotes.Factory changeNotesFactory, ChangeData.Factory changeDataFactory, Project.NameKey projectName, PermissionBackend.ForProject forProject, Repository repository, ImmutableSet<Change.Id> changes) {
}
(line 65,col 3)-(line 94,col 3)slice vertexes: 1




commit msg: Add more logging around GitVisibleChangeFilter and remove possible duplicates
v1: 74f27feea28c3ae8a3e9c1027b31e4006fe3a5ec    v2: 12ab14dca318beb58c0473c7b29d6978de09bba0
file name: GitVisibleChangeFilter.java
change region: 
(line 76,col 0)-(line 76,col 0)
original method: 
static ImmutableMap<Change.Id, ChangeData> getVisibleChanges(@Nullable SearchingChangeCacheImpl searchingChangeCache, ChangeNotes.Factory changeNotesFactory, ChangeData.Factory changeDataFactory, Project.NameKey projectName, PermissionBackend.ForProject forProject, Repository repository, ImmutableSet<Change.Id> changes) {
    Stream<ChangeData> changeDatas;
    if (changes.size() < CHANGE_LIMIT_FOR_DIRECT_FILTERING) {
        changeDatas = loadChangeDatasOneByOne(changes, changeDataFactory, projectName);
    } else if (searchingChangeCache != null) {
        changeDatas = searchingChangeCache.getChangeData(projectName);
    } else {
        changeDatas = scanRepoForChangeDatas(changeNotesFactory, changeDataFactory, repository, projectName);
    }
    return changeDatas.filter(cd -> changes.contains(cd.getId())).filter(cd -> {
        try {
            return forProject.change(cd).test(ChangePermission.READ);
        } catch (PermissionBackendException e) {
            throw new StorageException(e);
        }
    }).collect(toImmutableMap(ChangeData::getId, Function.identity()));
}
(line 65,col 3)-(line 94,col 3)
original graph vertexes: 9
sliced method: 
static ImmutableMap<Change.Id, ChangeData> getVisibleChanges(@Nullable SearchingChangeCacheImpl searchingChangeCache, ChangeNotes.Factory changeNotesFactory, ChangeData.Factory changeDataFactory, Project.NameKey projectName, PermissionBackend.ForProject forProject, Repository repository, ImmutableSet<Change.Id> changes) {
}
(line 65,col 3)-(line 94,col 3)slice vertexes: 1




commit msg: Add more logging around GitVisibleChangeFilter and remove possible duplicates
v1: 74f27feea28c3ae8a3e9c1027b31e4006fe3a5ec    v2: 12ab14dca318beb58c0473c7b29d6978de09bba0
file name: GitVisibleChangeFilter.java
change region: 
(line 78,col 0)-(line 78,col 0)
original method: 
static ImmutableMap<Change.Id, ChangeData> getVisibleChanges(@Nullable SearchingChangeCacheImpl searchingChangeCache, ChangeNotes.Factory changeNotesFactory, ChangeData.Factory changeDataFactory, Project.NameKey projectName, PermissionBackend.ForProject forProject, Repository repository, ImmutableSet<Change.Id> changes) {
    Stream<ChangeData> changeDatas;
    if (changes.size() < CHANGE_LIMIT_FOR_DIRECT_FILTERING) {
        changeDatas = loadChangeDatasOneByOne(changes, changeDataFactory, projectName);
    } else if (searchingChangeCache != null) {
        changeDatas = searchingChangeCache.getChangeData(projectName);
    } else {
        changeDatas = scanRepoForChangeDatas(changeNotesFactory, changeDataFactory, repository, projectName);
    }
    return changeDatas.filter(cd -> changes.contains(cd.getId())).filter(cd -> {
        try {
            return forProject.change(cd).test(ChangePermission.READ);
        } catch (PermissionBackendException e) {
            throw new StorageException(e);
        }
    }).collect(toImmutableMap(ChangeData::getId, Function.identity()));
}
(line 65,col 3)-(line 94,col 3)
original graph vertexes: 9
sliced method: 
static ImmutableMap<Change.Id, ChangeData> getVisibleChanges(@Nullable SearchingChangeCacheImpl searchingChangeCache, ChangeNotes.Factory changeNotesFactory, ChangeData.Factory changeDataFactory, Project.NameKey projectName, PermissionBackend.ForProject forProject, Repository repository, ImmutableSet<Change.Id> changes) {
}
(line 65,col 3)-(line 94,col 3)slice vertexes: 1




commit msg: Add more logging around GitVisibleChangeFilter and remove possible duplicates
v1: 74f27feea28c3ae8a3e9c1027b31e4006fe3a5ec    v2: 12ab14dca318beb58c0473c7b29d6978de09bba0
file name: GitVisibleChangeFilter.java
change region: 
(line 81,col 0)-(line 83,col 0)
original method: 
static ImmutableMap<Change.Id, ChangeData> getVisibleChanges(@Nullable SearchingChangeCacheImpl searchingChangeCache, ChangeNotes.Factory changeNotesFactory, ChangeData.Factory changeDataFactory, Project.NameKey projectName, PermissionBackend.ForProject forProject, Repository repository, ImmutableSet<Change.Id> changes) {
    Stream<ChangeData> changeDatas;
    if (changes.size() < CHANGE_LIMIT_FOR_DIRECT_FILTERING) {
        changeDatas = loadChangeDatasOneByOne(changes, changeDataFactory, projectName);
    } else if (searchingChangeCache != null) {
        changeDatas = searchingChangeCache.getChangeData(projectName);
    } else {
        changeDatas = scanRepoForChangeDatas(changeNotesFactory, changeDataFactory, repository, projectName);
    }
    return changeDatas.filter(cd -> changes.contains(cd.getId())).filter(cd -> {
        try {
            return forProject.change(cd).test(ChangePermission.READ);
        } catch (PermissionBackendException e) {
            throw new StorageException(e);
        }
    }).collect(toImmutableMap(ChangeData::getId, Function.identity()));
}
(line 65,col 3)-(line 94,col 3)
original graph vertexes: 9
sliced method: 
static ImmutableMap<Change.Id, ChangeData> getVisibleChanges(@Nullable SearchingChangeCacheImpl searchingChangeCache, ChangeNotes.Factory changeNotesFactory, ChangeData.Factory changeDataFactory, Project.NameKey projectName, PermissionBackend.ForProject forProject, Repository repository, ImmutableSet<Change.Id> changes) {
    Stream<ChangeData> changeDatas;
    if (changes.size() < CHANGE_LIMIT_FOR_DIRECT_FILTERING) {
        changeDatas = loadChangeDatasOneByOne(changes, changeDataFactory, projectName);
    } else if (searchingChangeCache != null) {
    } else {
        changeDatas = scanRepoForChangeDatas(changeNotesFactory, changeDataFactory, repository, projectName);
    }
    return changeDatas.filter(cd -> changes.contains(cd.getId())).filter(cd -> {
    }).collect(toImmutableMap(ChangeData::getId, Function.identity()));
}
(line 65,col 3)-(line 94,col 3)slice vertexes: 8




commit msg: Add more logging around GitVisibleChangeFilter and remove possible duplicates
v1: 74f27feea28c3ae8a3e9c1027b31e4006fe3a5ec    v2: 12ab14dca318beb58c0473c7b29d6978de09bba0
file name: GitVisibleChangeFilter.java
change region: 
(line 92,col 0)-(line 93,col 0)
original method: 
static ImmutableMap<Change.Id, ChangeData> getVisibleChanges(@Nullable SearchingChangeCacheImpl searchingChangeCache, ChangeNotes.Factory changeNotesFactory, ChangeData.Factory changeDataFactory, Project.NameKey projectName, PermissionBackend.ForProject forProject, Repository repository, ImmutableSet<Change.Id> changes) {
    Stream<ChangeData> changeDatas;
    if (changes.size() < CHANGE_LIMIT_FOR_DIRECT_FILTERING) {
        changeDatas = loadChangeDatasOneByOne(changes, changeDataFactory, projectName);
    } else if (searchingChangeCache != null) {
        changeDatas = searchingChangeCache.getChangeData(projectName);
    } else {
        changeDatas = scanRepoForChangeDatas(changeNotesFactory, changeDataFactory, repository, projectName);
    }
    return changeDatas.filter(cd -> changes.contains(cd.getId())).filter(cd -> {
        try {
            return forProject.change(cd).test(ChangePermission.READ);
        } catch (PermissionBackendException e) {
            throw new StorageException(e);
        }
    }).collect(toImmutableMap(ChangeData::getId, Function.identity()));
}
(line 65,col 3)-(line 94,col 3)
original graph vertexes: 9
sliced method: 
static ImmutableMap<Change.Id, ChangeData> getVisibleChanges(@Nullable SearchingChangeCacheImpl searchingChangeCache, ChangeNotes.Factory changeNotesFactory, ChangeData.Factory changeDataFactory, Project.NameKey projectName, PermissionBackend.ForProject forProject, Repository repository, ImmutableSet<Change.Id> changes) {
}
(line 65,col 3)-(line 94,col 3)slice vertexes: 1




commit msg: Merge "Handle 'cansee:<change>' account search operator for private changes"
v1: 8c2119c9c2878cf7d34090f5d4bf0ca27510d678    v2: 1bef1f7956dbdf072cf115bf43353197311f47c4
file name: AccountQueryBuilder.java
change region: 
(line 123,col 0)-(line 124,col 0)
original method: 
@Operator
public Predicate<AccountState> cansee(String change) throws QueryParseException, PermissionBackendException {
    Optional<ChangeNotes> changeNotes = args.changeFinder.findOne(change);
    if (!changeNotes.isPresent()) {
        throw error(String.format("change %s not found", change));
    }
    if (!args.permissionBackend.user(args.getUser()).change(changeNotes.get()).test(ChangePermission.READ)) {
        throw error(String.format("change %s not found", change));
    }
    return AccountPredicates.cansee(args, changeNotes.get());
}
(line 117,col 3)-(line 132,col 3)
original graph vertexes: 7
sliced method: 
@Operator
public Predicate<AccountState> cansee(String change) throws QueryParseException, PermissionBackendException {
}
(line 117,col 3)-(line 132,col 3)slice vertexes: 1




commit msg: Merge "Handle 'cansee:<change>' account search operator for private changes"
v1: 8c2119c9c2878cf7d34090f5d4bf0ca27510d678    v2: 1bef1f7956dbdf072cf115bf43353197311f47c4
file name: AccountQueryBuilder.java
change region: 
(line 233,col 0)-(line 233,col 0)
original method: 
private boolean checkedCanSeeSecondaryEmails() {
    try {
        return canSeeSecondaryEmails();
    } catch (PermissionBackendException e) {
        logger.atSevere().withCause(e).log("Permission check failed");
        return false;
    } catch (QueryParseException e) {
        return false;
    }
}
(line 223,col 3)-(line 233,col 3)
original graph vertexes: 3
sliced method: 
private boolean checkedCanSeeSecondaryEmails() {
}
(line 223,col 3)-(line 233,col 3)slice vertexes: 1




commit msg: Handle 'cansee:<change>' account search operator for private changes
v1: fc84673c6d3b75b24dbd7a72a70d962258edb3a3    v2: 0bc2475f7b4705e66d280b4e81919d07eca52ac9
file name: AccountQueryBuilder.java
change region: 
(line 123,col 0)-(line 124,col 0)
original method: 
@Operator
public Predicate<AccountState> cansee(String change) throws QueryParseException, PermissionBackendException {
    Optional<ChangeNotes> changeNotes = args.changeFinder.findOne(change);
    if (!changeNotes.isPresent()) {
        throw error(String.format("change %s not found", change));
    }
    if (!args.permissionBackend.user(args.getUser()).change(changeNotes.get()).test(ChangePermission.READ)) {
        throw error(String.format("change %s not found", change));
    }
    return AccountPredicates.cansee(args, changeNotes.get());
}
(line 117,col 3)-(line 132,col 3)
original graph vertexes: 7
sliced method: 
@Operator
public Predicate<AccountState> cansee(String change) throws QueryParseException, PermissionBackendException {
}
(line 117,col 3)-(line 132,col 3)slice vertexes: 1




commit msg: Handle 'cansee:<change>' account search operator for private changes
v1: fc84673c6d3b75b24dbd7a72a70d962258edb3a3    v2: 0bc2475f7b4705e66d280b4e81919d07eca52ac9
file name: AccountQueryBuilder.java
change region: 
(line 233,col 0)-(line 233,col 0)
original method: 
private boolean checkedCanSeeSecondaryEmails() {
    try {
        return canSeeSecondaryEmails();
    } catch (PermissionBackendException e) {
        logger.atSevere().withCause(e).log("Permission check failed");
        return false;
    } catch (QueryParseException e) {
        return false;
    }
}
(line 223,col 3)-(line 233,col 3)
original graph vertexes: 3
sliced method: 
private boolean checkedCanSeeSecondaryEmails() {
}
(line 223,col 3)-(line 233,col 3)slice vertexes: 1




commit msg: Merge "Support file-mode modification for REST API PUT"
v1: b3f328f57b631db6d2fa8baaa45f4150d1c0bcbe    v2: f164b6ecd41314405b39381ba0768211aae40730
file name: FileContentBuilder.java
change region: 
(line 46,col 0)-(line 47,col 0)
original method: 
public T content(String content) {
    checkNotNull(Strings.emptyToNull(content), "Empty file content is not supported. Adjust test API if necessary.");
    modificationToBuilderAdder.accept(new ChangeFileContentModification(filePath, RawInputUtil.create(content)));
    return builder;
}
(line 42,col 3)-(line 49,col 3)
original graph vertexes: 4
sliced method: 
public T content(String content) {
}
(line 42,col 3)-(line 49,col 3)slice vertexes: 1




commit msg: Merge "Support file-mode modification for REST API PUT"
v1: b3f328f57b631db6d2fa8baaa45f4150d1c0bcbe    v2: f164b6ecd41314405b39381ba0768211aae40730
file name: ChangeEditModifier.java
change region: 
(line 242,col 0)-(line 243,col 0)
original method: 
public void modifyFile(Repository repository, ChangeNotes notes, String filePath, RawInput newContent) throws AuthException, BadRequestException, InvalidChangeOperationException, IOException, PermissionBackendException, ResourceConflictException {
    modifyCommit(repository, notes, new ModificationIntention.LatestCommit(), CommitModification.builder().addTreeModification(new ChangeFileContentModification(filePath, newContent)).build());
}
(line 234,col 3)-(line 245,col 3)
original graph vertexes: 2
sliced method: 
public void modifyFile(Repository repository, ChangeNotes notes, String filePath, RawInput newContent) throws AuthException, BadRequestException, InvalidChangeOperationException, IOException, PermissionBackendException, ResourceConflictException {
}
(line 234,col 3)-(line 245,col 3)slice vertexes: 1




commit msg: Merge "Support file-mode modification for REST API PUT"
v1: b3f328f57b631db6d2fa8baaa45f4150d1c0bcbe    v2: f164b6ecd41314405b39381ba0768211aae40730
file name: ChangeFileContentModification.java
change region: 
(line 53,col 0)-(line 54,col 0)
original method: 
@Override
public List<DirCacheEditor.PathEdit> getPathEdits(Repository repository, ObjectId treeId, ImmutableList<? extends ObjectId> parents) {
    DirCacheEditor.PathEdit changeContentEdit = new ChangeContent(filePath, newContent, repository);
    return Collections.singletonList(changeContentEdit);
}
(line 51,col 3)-(line 56,col 3)
original graph vertexes: 3
sliced method: 
@Override
public List<DirCacheEditor.PathEdit> getPathEdits(Repository repository, ObjectId treeId, ImmutableList<? extends ObjectId> parents) {
    DirCacheEditor.PathEdit changeContentEdit = new ChangeContent(filePath, newContent, repository);
    return Collections.singletonList(changeContentEdit);
}
(line 51,col 3)-(line 56,col 3)slice vertexes: 3




commit msg: Merge "Support file-mode modification for REST API PUT"
v1: b3f328f57b631db6d2fa8baaa45f4150d1c0bcbe    v2: f164b6ecd41314405b39381ba0768211aae40730
file name: ChangeFileContentModification.java
change region: 
(line 82,col 0)-(line 82,col 0)
original method: 
@Override
public void apply(DirCacheEntry dirCacheEntry) {
    try {
        if (dirCacheEntry.getFileMode() == FileMode.GITLINK) {
            dirCacheEntry.setLength(0);
            dirCacheEntry.setLastModified(Instant.EPOCH);
            ObjectId newObjectId = ObjectId.fromString(getNewContentBytes(), 0);
            dirCacheEntry.setObjectId(newObjectId);
        } else {
            if (dirCacheEntry.getRawMode() == 0) {
                dirCacheEntry.setFileMode(FileMode.REGULAR_FILE);
            }
            ObjectId newBlobObjectId = createNewBlobAndGetItsId();
            dirCacheEntry.setObjectId(newBlobObjectId);
        }
    } catch (IOException e) {
        String message = String.format("Could not change the content of %s", dirCacheEntry.getPathString());
        logger.atSevere().withCause(e).log("%s", message);
    } catch (InvalidObjectIdException e) {
        logger.atSevere().withCause(e).log("Invalid object id in submodule link");
    }
}
(line 80,col 5)-(line 105,col 5)
original graph vertexes: 13
sliced method: 
@Override
public void apply(DirCacheEntry dirCacheEntry) {
}
(line 80,col 5)-(line 105,col 5)slice vertexes: 1




commit msg: Merge "Support file-mode modification for REST API PUT"
v1: b3f328f57b631db6d2fa8baaa45f4150d1c0bcbe    v2: f164b6ecd41314405b39381ba0768211aae40730
file name: ChangeEdits.java
change region: 
(line 342,col 0)-(line 342,col 0)
original method: 
public Response<Object> apply(ChangeResource rsrc, String path, FileContentInput fileContentInput) throws AuthException, BadRequestException, ResourceConflictException, IOException, PermissionBackendException {
    if (fileContentInput.content == null && fileContentInput.binary_content == null) {
        throw new BadRequestException("either content or binary_content is required");
    }
    RawInput newContent;
    if (fileContentInput.binary_content != null) {
        Matcher m = BINARY_DATA_PATTERN.matcher(fileContentInput.binary_content);
        if (m.matches() && BASE64.equals(m.group(2))) {
            newContent = RawInputUtil.create(Base64.decode(m.group(3)));
        } else {
            throw new BadRequestException("binary_content must be encoded as base64 data uri");
        }
    } else {
        newContent = fileContentInput.content;
    }
    if (Patch.COMMIT_MSG.equals(path) && fileContentInput.binary_content == null) {
        EditMessage.Input editMessageInput = new EditMessage.Input();
        editMessageInput.message = new String(ByteStreams.toByteArray(newContent.getInputStream()), UTF_8);
        return editMessage.apply(rsrc, editMessageInput);
    }
    if (Strings.isNullOrEmpty(path) || path.charAt(0) == '/') {
        throw new ResourceConflictException("Invalid path: " + path);
    }
    try (Repository repository = repositoryManager.openRepository(rsrc.getProject())) {
        editModifier.modifyFile(repository, rsrc.getNotes(), path, newContent);
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
(line 311,col 5)-(line 349,col 5)
original graph vertexes: 21
sliced method: 
public Response<Object> apply(ChangeResource rsrc, String path, FileContentInput fileContentInput) throws AuthException, BadRequestException, ResourceConflictException, IOException, PermissionBackendException {
}
(line 311,col 5)-(line 349,col 5)slice vertexes: 1




commit msg: Merge "Support file-mode modification for REST API PUT"
v1: b3f328f57b631db6d2fa8baaa45f4150d1c0bcbe    v2: f164b6ecd41314405b39381ba0768211aae40730
file name: ChangeEdits.java
change region: 
(line 343,col 0)-(line 344,col 0)
original method: 
public Response<Object> apply(ChangeResource rsrc, String path, FileContentInput fileContentInput) throws AuthException, BadRequestException, ResourceConflictException, IOException, PermissionBackendException {
    if (fileContentInput.content == null && fileContentInput.binary_content == null) {
        throw new BadRequestException("either content or binary_content is required");
    }
    RawInput newContent;
    if (fileContentInput.binary_content != null) {
        Matcher m = BINARY_DATA_PATTERN.matcher(fileContentInput.binary_content);
        if (m.matches() && BASE64.equals(m.group(2))) {
            newContent = RawInputUtil.create(Base64.decode(m.group(3)));
        } else {
            throw new BadRequestException("binary_content must be encoded as base64 data uri");
        }
    } else {
        newContent = fileContentInput.content;
    }
    if (Patch.COMMIT_MSG.equals(path) && fileContentInput.binary_content == null) {
        EditMessage.Input editMessageInput = new EditMessage.Input();
        editMessageInput.message = new String(ByteStreams.toByteArray(newContent.getInputStream()), UTF_8);
        return editMessage.apply(rsrc, editMessageInput);
    }
    if (Strings.isNullOrEmpty(path) || path.charAt(0) == '/') {
        throw new ResourceConflictException("Invalid path: " + path);
    }
    try (Repository repository = repositoryManager.openRepository(rsrc.getProject())) {
        editModifier.modifyFile(repository, rsrc.getNotes(), path, newContent);
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
(line 311,col 5)-(line 349,col 5)
original graph vertexes: 21
sliced method: 
public Response<Object> apply(ChangeResource rsrc, String path, FileContentInput fileContentInput) throws AuthException, BadRequestException, ResourceConflictException, IOException, PermissionBackendException {
    RawInput newContent;
    try (Repository repository = repositoryManager.openRepository(rsrc.getProject())) {
        editModifier.modifyFile(repository, rsrc.getNotes(), path, newContent);
    } catch (InvalidChangeOperationException e) {
    }
}
(line 311,col 5)-(line 349,col 5)slice vertexes: 4




commit msg: Support file-mode modification for REST API PUT
v1: 72dd4d9fafa96679ce9ecdfabcfa09d2c9bc97e4    v2: 4ca10417dc53f1d6847e670ca0109637e98183fd
file name: FileContentBuilder.java
change region: 
(line 46,col 0)-(line 47,col 0)
original method: 
public T content(String content) {
    checkNotNull(Strings.emptyToNull(content), "Empty file content is not supported. Adjust test API if necessary.");
    modificationToBuilderAdder.accept(new ChangeFileContentModification(filePath, RawInputUtil.create(content)));
    return builder;
}
(line 42,col 3)-(line 49,col 3)
original graph vertexes: 4
sliced method: 
public T content(String content) {
}
(line 42,col 3)-(line 49,col 3)slice vertexes: 1




commit msg: Support file-mode modification for REST API PUT
v1: 72dd4d9fafa96679ce9ecdfabcfa09d2c9bc97e4    v2: 4ca10417dc53f1d6847e670ca0109637e98183fd
file name: ChangeEditModifier.java
change region: 
(line 242,col 0)-(line 243,col 0)
original method: 
public void modifyFile(Repository repository, ChangeNotes notes, String filePath, RawInput newContent) throws AuthException, BadRequestException, InvalidChangeOperationException, IOException, PermissionBackendException, ResourceConflictException {
    modifyCommit(repository, notes, new ModificationIntention.LatestCommit(), CommitModification.builder().addTreeModification(new ChangeFileContentModification(filePath, newContent)).build());
}
(line 234,col 3)-(line 245,col 3)
original graph vertexes: 2
sliced method: 
public void modifyFile(Repository repository, ChangeNotes notes, String filePath, RawInput newContent) throws AuthException, BadRequestException, InvalidChangeOperationException, IOException, PermissionBackendException, ResourceConflictException {
}
(line 234,col 3)-(line 245,col 3)slice vertexes: 1




commit msg: Support file-mode modification for REST API PUT
v1: 72dd4d9fafa96679ce9ecdfabcfa09d2c9bc97e4    v2: 4ca10417dc53f1d6847e670ca0109637e98183fd
file name: ChangeFileContentModification.java
change region: 
(line 53,col 0)-(line 54,col 0)
original method: 
@Override
public List<DirCacheEditor.PathEdit> getPathEdits(Repository repository, ObjectId treeId, ImmutableList<? extends ObjectId> parents) {
    DirCacheEditor.PathEdit changeContentEdit = new ChangeContent(filePath, newContent, repository);
    return Collections.singletonList(changeContentEdit);
}
(line 51,col 3)-(line 56,col 3)
original graph vertexes: 3
sliced method: 
@Override
public List<DirCacheEditor.PathEdit> getPathEdits(Repository repository, ObjectId treeId, ImmutableList<? extends ObjectId> parents) {
    DirCacheEditor.PathEdit changeContentEdit = new ChangeContent(filePath, newContent, repository);
    return Collections.singletonList(changeContentEdit);
}
(line 51,col 3)-(line 56,col 3)slice vertexes: 3




commit msg: Support file-mode modification for REST API PUT
v1: 72dd4d9fafa96679ce9ecdfabcfa09d2c9bc97e4    v2: 4ca10417dc53f1d6847e670ca0109637e98183fd
file name: ChangeFileContentModification.java
change region: 
(line 82,col 0)-(line 82,col 0)
original method: 
@Override
public void apply(DirCacheEntry dirCacheEntry) {
    try {
        if (dirCacheEntry.getFileMode() == FileMode.GITLINK) {
            dirCacheEntry.setLength(0);
            dirCacheEntry.setLastModified(Instant.EPOCH);
            ObjectId newObjectId = ObjectId.fromString(getNewContentBytes(), 0);
            dirCacheEntry.setObjectId(newObjectId);
        } else {
            if (dirCacheEntry.getRawMode() == 0) {
                dirCacheEntry.setFileMode(FileMode.REGULAR_FILE);
            }
            ObjectId newBlobObjectId = createNewBlobAndGetItsId();
            dirCacheEntry.setObjectId(newBlobObjectId);
        }
    } catch (IOException e) {
        String message = String.format("Could not change the content of %s", dirCacheEntry.getPathString());
        logger.atSevere().withCause(e).log("%s", message);
    } catch (InvalidObjectIdException e) {
        logger.atSevere().withCause(e).log("Invalid object id in submodule link");
    }
}
(line 80,col 5)-(line 105,col 5)
original graph vertexes: 13
sliced method: 
@Override
public void apply(DirCacheEntry dirCacheEntry) {
}
(line 80,col 5)-(line 105,col 5)slice vertexes: 1




commit msg: Support file-mode modification for REST API PUT
v1: 72dd4d9fafa96679ce9ecdfabcfa09d2c9bc97e4    v2: 4ca10417dc53f1d6847e670ca0109637e98183fd
file name: ChangeEdits.java
change region: 
(line 342,col 0)-(line 342,col 0)
original method: 
public Response<Object> apply(ChangeResource rsrc, String path, FileContentInput fileContentInput) throws AuthException, BadRequestException, ResourceConflictException, IOException, PermissionBackendException {
    if (fileContentInput.content == null && fileContentInput.binary_content == null) {
        throw new BadRequestException("either content or binary_content is required");
    }
    RawInput newContent;
    if (fileContentInput.binary_content != null) {
        Matcher m = BINARY_DATA_PATTERN.matcher(fileContentInput.binary_content);
        if (m.matches() && BASE64.equals(m.group(2))) {
            newContent = RawInputUtil.create(Base64.decode(m.group(3)));
        } else {
            throw new BadRequestException("binary_content must be encoded as base64 data uri");
        }
    } else {
        newContent = fileContentInput.content;
    }
    if (Patch.COMMIT_MSG.equals(path) && fileContentInput.binary_content == null) {
        EditMessage.Input editMessageInput = new EditMessage.Input();
        editMessageInput.message = new String(ByteStreams.toByteArray(newContent.getInputStream()), UTF_8);
        return editMessage.apply(rsrc, editMessageInput);
    }
    if (Strings.isNullOrEmpty(path) || path.charAt(0) == '/') {
        throw new ResourceConflictException("Invalid path: " + path);
    }
    try (Repository repository = repositoryManager.openRepository(rsrc.getProject())) {
        editModifier.modifyFile(repository, rsrc.getNotes(), path, newContent);
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
(line 311,col 5)-(line 349,col 5)
original graph vertexes: 21
sliced method: 
public Response<Object> apply(ChangeResource rsrc, String path, FileContentInput fileContentInput) throws AuthException, BadRequestException, ResourceConflictException, IOException, PermissionBackendException {
}
(line 311,col 5)-(line 349,col 5)slice vertexes: 1




commit msg: Support file-mode modification for REST API PUT
v1: 72dd4d9fafa96679ce9ecdfabcfa09d2c9bc97e4    v2: 4ca10417dc53f1d6847e670ca0109637e98183fd
file name: ChangeEdits.java
change region: 
(line 343,col 0)-(line 344,col 0)
original method: 
public Response<Object> apply(ChangeResource rsrc, String path, FileContentInput fileContentInput) throws AuthException, BadRequestException, ResourceConflictException, IOException, PermissionBackendException {
    if (fileContentInput.content == null && fileContentInput.binary_content == null) {
        throw new BadRequestException("either content or binary_content is required");
    }
    RawInput newContent;
    if (fileContentInput.binary_content != null) {
        Matcher m = BINARY_DATA_PATTERN.matcher(fileContentInput.binary_content);
        if (m.matches() && BASE64.equals(m.group(2))) {
            newContent = RawInputUtil.create(Base64.decode(m.group(3)));
        } else {
            throw new BadRequestException("binary_content must be encoded as base64 data uri");
        }
    } else {
        newContent = fileContentInput.content;
    }
    if (Patch.COMMIT_MSG.equals(path) && fileContentInput.binary_content == null) {
        EditMessage.Input editMessageInput = new EditMessage.Input();
        editMessageInput.message = new String(ByteStreams.toByteArray(newContent.getInputStream()), UTF_8);
        return editMessage.apply(rsrc, editMessageInput);
    }
    if (Strings.isNullOrEmpty(path) || path.charAt(0) == '/') {
        throw new ResourceConflictException("Invalid path: " + path);
    }
    try (Repository repository = repositoryManager.openRepository(rsrc.getProject())) {
        editModifier.modifyFile(repository, rsrc.getNotes(), path, newContent);
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
(line 311,col 5)-(line 349,col 5)
original graph vertexes: 21
sliced method: 
public Response<Object> apply(ChangeResource rsrc, String path, FileContentInput fileContentInput) throws AuthException, BadRequestException, ResourceConflictException, IOException, PermissionBackendException {
    RawInput newContent;
    if (fileContentInput.binary_content != null) {
        if (m.matches() && BASE64.equals(m.group(2))) {
            newContent = RawInputUtil.create(Base64.decode(m.group(3)));
        } else {
        }
    } else {
    }
    try (Repository repository = repositoryManager.openRepository(rsrc.getProject())) {
        editModifier.modifyFile(repository, rsrc.getNotes(), path, newContent);
    } catch (InvalidChangeOperationException e) {
    }
}
(line 311,col 5)-(line 349,col 5)slice vertexes: 9




